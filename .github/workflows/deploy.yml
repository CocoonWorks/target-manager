name: Build and Deploy to VPS

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch: # Allow manual triggering

env:
  NODE_VERSION: "18"
  APP_NAME: "task-manager"

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Install Prefixers
        run: npm install autoprefixer postcss

      - name: Build application
        run: npm run build
        env:
          # Add any build-time environment variables here
          NODE_ENV: production

      - name: Create deployment package
        run: |
          # Create a deployment directory
          mkdir -p deployment

          # Copy built files and necessary files
          cp -r .next deployment/
          cp -r public deployment/ 2>/dev/null || true
          cp package*.json deployment/
          cp next.config.js deployment/
          cp tailwind.config.js deployment/
          cp postcss.config.js deployment/
          cp tsconfig.json deployment/

          # Prepare production node_modules to avoid network install on VPS
          npm prune --omit=dev
          cp -r node_modules deployment/

          # Create deployment script
          cat > deployment/deploy.sh << 'EOF'
          #!/bin/bash
          set -euo pipefail
          echo "Starting deployment..."

          # Stop the application if running
          pm2 stop $APP_NAME 2>/dev/null || true

          # Use packaged node_modules (built on CI)
          if [ -d node_modules ]; then
            echo "Using packaged node_modules"
          else
            echo "node_modules not found; attempting install (may require network)"
            npm ci --omit=dev || true
          fi

          # Start the application
          export PORT=3001
          if pm2 describe "$APP_NAME" >/dev/null 2>&1; then
            pm2 restart "$APP_NAME" --update-env || true
          fi
          pm2 start npm --name "$APP_NAME" -- start || pm2 restart "$APP_NAME" --update-env || true
          pm2 save

          echo "PM2 status after (re)start:"
          pm2 status "$APP_NAME"
          echo "Last 60 lines of app logs:"
          pm2 logs "$APP_NAME" --lines 60 --nostream || true

          echo "Deployment completed!"
          EOF

          chmod +x deployment/deploy.sh

          # Create tar archive
          tar -czf ${{ env.APP_NAME }}-deployment.tar.gz -C deployment .

      - name: Deploy to VPS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          command_timeout: 15m
          debug: true
          script: |
            # Create deployment directory
            mkdir -p /home/${{ secrets.VPS_USERNAME }}/deployments
            cd /home/${{ secrets.VPS_USERNAME }}/deployments

            # Create backup of current deployment
            if [ -d "${{ env.APP_NAME }}" ]; then
              mv ${{ env.APP_NAME }} ${{ env.APP_NAME }}-backup-$(date +%Y%m%d-%H%M%S)
            fi

            # Create new deployment directory
            mkdir -p ${{ env.APP_NAME }}
            cd ${{ env.APP_NAME }}

      - name: Copy files to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          source: "${{ env.APP_NAME }}-deployment.tar.gz"
          target: "/home/${{ secrets.VPS_USERNAME }}/deployments/${{ env.APP_NAME }}/"

      - name: Extract and deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          command_timeout: 20m
          debug: true
          script: |
            cd /home/${{ secrets.VPS_USERNAME }}/deployments/${{ env.APP_NAME }}

            # Extract deployment package
            tar -xzf ${{ env.APP_NAME }}-deployment.tar.gz
            rm ${{ env.APP_NAME }}-deployment.tar.gz

            # Write environment file from GitHub Secrets
            cat > /home/${{ secrets.VPS_USERNAME }}/.env.production << 'EOF'
            ${{ secrets.ENV_PRODUCTION }}
            EOF
            chmod 600 /home/${{ secrets.VPS_USERNAME }}/.env.production

            # Copy environment file if it exists
            if [ -f /home/${{ secrets.VPS_USERNAME }}/.env.production ]; then
              cp /home/${{ secrets.VPS_USERNAME }}/.env.production .env.local
            fi

            # Set environment variables for deployment
            export APP_NAME="${{ env.APP_NAME }}"

            # Run deployment script
            ./deploy.sh

            # Cleanup old backups (keep last 3)
            cd /home/${{ secrets.VPS_USERNAME }}/deployments
            ls -t | grep "${{ env.APP_NAME }}-backup-" | tail -n +4 | xargs rm -rf

      - name: Verify deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          script_stop: true
          command_timeout: 5m
          debug: true
          script: |
            # Check if the application is running
            pm2 status ${{ env.APP_NAME }}
            # Health check
            if ! curl -fsS http://127.0.0.1:3001/api/health; then
              echo "Health check failed. Recent logs:"
              pm2 logs ${{ env.APP_NAME }} --lines 120 --nostream || true
              exit 1
            fi

      - name: Cleanup
        if: always()
        run: |
          rm -f ${{ env.APP_NAME }}-deployment.tar.gz
          rm -rf deployment
